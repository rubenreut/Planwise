import Foundation
import CoreData
import SwiftUI

@MainActor
class ScheduleManager: NSObject, ObservableObject {
    static let shared = ScheduleManager()
    
    @Published private(set) var events: [Event] = []
    @Published private(set) var categories: [Category] = []
    @Published private(set) var isLoading = false
    @Published private(set) var lastError: String?
    
    private let persistence = PersistenceController.shared
    private var fetchedResultsController: NSFetchedResultsController<Event>?
    private var categoriesFetchedResultsController: NSFetchedResultsController<Category>?
    
    private override init() {
        super.init()
        setupFetchedResultsControllers()
        fetchEvents()
        fetchCategories()
    }
    
    // MARK: - Setup
    private func setupFetchedResultsControllers() {
        // Events controller
        let eventRequest: NSFetchRequest<Event> = Event.fetchRequest()
        eventRequest.sortDescriptors = [
            NSSortDescriptor(keyPath: \Event.startTime, ascending: true)
        ]
        
        fetchedResultsController = NSFetchedResultsController(
            fetchRequest: eventRequest,
            managedObjectContext: persistence.container.viewContext,
            sectionNameKeyPath: nil,
            cacheName: nil
        )
        fetchedResultsController?.delegate = self
        
        // Categories controller
        let categoryRequest: NSFetchRequest<Category> = Category.fetchRequest()
        categoryRequest.sortDescriptors = [
            NSSortDescriptor(keyPath: \Category.sortOrder, ascending: true),
            NSSortDescriptor(keyPath: \Category.name, ascending: true)
        ]
        categoryRequest.predicate = NSPredicate(format: "isActive == YES")
        
        categoriesFetchedResultsController = NSFetchedResultsController(
            fetchRequest: categoryRequest,
            managedObjectContext: persistence.container.viewContext,
            sectionNameKeyPath: nil,
            cacheName: nil
        )
        categoriesFetchedResultsController?.delegate = self
    }
    
    // MARK: - Fetching
    func forceRefresh() {
        fetchEvents()
        objectWillChange.send()
    }
    
    private func fetchEvents() {
        isLoading = true
        
        persistence.performAndMeasure("Fetch all events") {
            do {
                try fetchedResultsController?.performFetch()
                events = fetchedResultsController?.fetchedObjects ?? []
                print("üìÖ Fetched \(events.count) events")
            } catch {
                lastError = "Failed to fetch events: \(error.localizedDescription)"
                print("‚ùå \(lastError ?? "")")
            }
        }
        
        isLoading = false
    }
    
    private func fetchCategories() {
        persistence.performAndMeasure("Fetch categories") {
            do {
                try categoriesFetchedResultsController?.performFetch()
                categories = categoriesFetchedResultsController?.fetchedObjects ?? []
                print("üìÅ Fetched \(categories.count) categories")
            } catch {
                lastError = "Failed to fetch categories: \(error.localizedDescription)"
                print("‚ùå \(lastError ?? "")")
            }
        }
    }
    
    // MARK: - Event CRUD Operations
    func createEvent(
        title: String,
        startTime: Date,
        endTime: Date,
        category: Category?,
        notes: String? = nil,
        location: String? = nil,
        isAllDay: Bool = false
    ) -> Result<Event, Error> {
        print("üìù Creating event: '\(title)'")
        print("   Start: \(startTime)")
        print("   End: \(endTime)")
        print("   Category: \(category?.name ?? "none")")
        print("   Notes: \(notes ?? "none")")
        print("   Location: \(location ?? "none")")
        print("   All Day: \(isAllDay)")
        
        let context = persistence.container.viewContext
        
        // Validation
        guard !title.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else {
            print("‚ùå Validation failed: empty title")
            return .failure(ScheduleError.invalidTitle)
        }
        
        guard endTime > startTime else {
            print("‚ùå Validation failed: invalid time range")
            return .failure(ScheduleError.invalidTimeRange)
        }
        
        print("‚úÖ Validation passed")
        
        let event = Event(context: context)
        print("üì¶ Created Event entity")
        
        // Set required fields one by one with error checking
        do {
            event.id = UUID()
            print("   Set ID: \(event.id!)")
            
            event.title = title.trimmingCharacters(in: .whitespacesAndNewlines)
            print("   Set title: \(event.title!)")
            
            event.startTime = startTime
            print("   Set startTime: \(event.startTime!)")
            
            event.endTime = endTime
            print("   Set endTime: \(event.endTime!)")
            
            if let category = category {
                event.category = category
                print("   Set category: \(category.name ?? "unknown")")
            }
            
            // Handle notes with ALL_DAY marker
            if isAllDay {
                event.notes = (notes ?? "") + "[ALL_DAY]"
            } else {
                event.notes = notes
            }
            print("   Set notes: \(event.notes ?? "none")")
            
            event.location = location
            print("   Set location: \(event.location ?? "none")")
            
            event.dataSource = "manual"
            print("   Set dataSource: manual")
            
            event.createdAt = Date()
            print("   Set createdAt: \(event.createdAt!)")
            
            event.modifiedAt = Date()
            print("   Set modifiedAt: \(event.modifiedAt!)")
            
            // Set other required Core Data fields with defaults
            event.isCompleted = false
            event.colorHex = category?.colorHex ?? "#007AFF"
            print("   Set colorHex: \(event.colorHex!)")
            
            print("üíæ Attempting to save context...")
            try context.save()
            print("‚úÖ Event created successfully: \(title)")
            return .success(event)
        } catch let error as NSError {
            lastError = "Failed to create event: \(error.localizedDescription)"
            print("‚ùå Save failed: \(error)")
            print("   Error code: \(error.code)")
            print("   Error domain: \(error.domain)")
            print("   Error userInfo: \(error.userInfo)")
            
            // Rollback
            context.rollback()
            print("üîÑ Context rolled back")
            
            return .failure(error)
        }
    }
    
    func updateEvent(
        _ event: Event,
        title: String? = nil,
        startTime: Date? = nil,
        endTime: Date? = nil,
        category: Category? = nil,
        notes: String? = nil,
        location: String? = nil,
        isCompleted: Bool? = nil
    ) -> Result<Void, Error> {
        let context = persistence.container.viewContext
        
        // Debug: Log the update request
        print("üîÑ DEBUG: updateEvent called")
        print("   Event: \(event.title ?? "Untitled")")
        print("   Current start: \(event.startTime ?? Date())")
        print("   Current end: \(event.endTime ?? Date())")
        print("   New start: \(startTime?.description ?? "nil")")
        print("   New end: \(endTime?.description ?? "nil")")
        
        if let title = title {
            guard !title.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else {
                return .failure(ScheduleError.invalidTitle)
            }
            event.title = title.trimmingCharacters(in: .whitespacesAndNewlines)
        }
        
        if let startTime = startTime {
            event.startTime = startTime
            print("   ‚úÖ Updated startTime to: \(startTime)")
        }
        
        if let endTime = endTime {
            event.endTime = endTime
            print("   ‚úÖ Updated endTime to: \(endTime)")
        
        // Validate time range if both times were updated
        if let start = event.startTime, let end = event.endTime {
            guard end > start else {
                return .failure(ScheduleError.invalidTimeRange)
            }
            // No duration field - calculate when needed
        }
        
        if let category = category {
            event.category = category
        }
        
        if let notes = notes {
            event.notes = notes
        }
        
        if let location = location {
            event.location = location
        }
        
        if let isCompleted = isCompleted {
            event.isCompleted = isCompleted
            if isCompleted {
                event.completedAt = Date()
            } else {
                event.completedAt = nil
            }
        }
        
        event.modifiedAt = Date()
        
        do {
            try context.save()
            print("‚úÖ Event updated: \(event.title ?? "")")
            print("   Final start: \(event.startTime ?? Date())")
            print("   Final end: \(event.endTime ?? Date())")
            
            // Debug: Check if event changed days
            if let oldStart = event.startTime, let newStart = startTime {
                let calendar = Calendar.current
                if !calendar.isDate(oldStart, inSameDayAs: newStart) {
                    print("   ‚ö†Ô∏è WARNING: Event moved to a different day!")
                    print("   Old day: \(calendar.startOfDay(for: oldStart))")
                    print("   New day: \(calendar.startOfDay(for: newStart))")
                }
            }
            
            return .success(())
        } catch {
            lastError = "Failed to update event: \(error.localizedDescription)"
            print("‚ùå \(lastError ?? "")")
            return .failure(error)
        }
    }
    
    func deleteEvent(_ event: Event) -> Result<Void, Error> {
        let context = persistence.container.viewContext
        
        context.delete(event)
        
        do {
            try context.save()
            print("‚úÖ Event deleted: \(event.title ?? "")")
            return .success(())
        } catch {
            lastError = "Failed to delete event: \(error.localizedDescription)"
            print("‚ùå \(lastError ?? "")")
            return .failure(error)
        }
    }
    
    // MARK: - Filtered Views
    func eventsForToday() -> [Event] {
        let calendar = Calendar.current
        let start = calendar.startOfDay(for: Date())
        let end = calendar.date(byAdding: .day, value: 1, to: start)!
        
        return events.filter { event in
            guard let eventStart = event.startTime else { return false }
            return eventStart >= start && eventStart < end
        }.sorted { ($0.startTime ?? Date.distantPast) < ($1.startTime ?? Date.distantPast) }
    }
    
    func eventsForWeek() -> [Event] {
        let calendar = Calendar.current
        let today = Date()
        
        guard let weekStart = calendar.dateInterval(of: .weekOfYear, for: today)?.start,
              let weekEnd = calendar.dateInterval(of: .weekOfYear, for: today)?.end else {
            return []
        }
        
        return events.filter { event in
            guard let eventStart = event.startTime else { return false }
            return eventStart >= weekStart && eventStart < weekEnd
        }.sorted { ($0.startTime ?? Date.distantPast) < ($1.startTime ?? Date.distantPast) }
    }
    
    func eventsForMonth() -> [Event] {
        let calendar = Calendar.current
        let today = Date()
        
        guard let monthStart = calendar.dateInterval(of: .month, for: today)?.start,
              let monthEnd = calendar.dateInterval(of: .month, for: today)?.end else {
            return []
        }
        
        return events.filter { event in
            guard let eventStart = event.startTime else { return false }
            return eventStart >= monthStart && eventStart < monthEnd
        }.sorted { ($0.startTime ?? Date.distantPast) < ($1.startTime ?? Date.distantPast) }
    }
    
    func events(for date: Date) -> [Event] {
        let calendar = Calendar.current
        let start = calendar.startOfDay(for: date)
        let end = calendar.date(byAdding: .day, value: 1, to: start)!
        
        print("üìÖ DEBUG: Filtering events for date: \(date)")
        print("   Start of day: \(start)")
        print("   End of day: \(end)")
        print("   Total events in manager: \(events.count)")
        
        let filteredEvents = events.filter { event in
            guard let eventStart = event.startTime else { 
                print("   ‚ö†Ô∏è Event '\(event.title ?? "Untitled")' has no start time")
                return false 
            }
            let isInRange = eventStart >= start && eventStart < end
            if !isInRange {
                print("   ‚ùå Event '\(event.title ?? "Untitled")' at \(eventStart) is outside range")
            } else {
                print("   ‚úÖ Event '\(event.title ?? "Untitled")' at \(eventStart) is in range")
            }
            return isInRange
        }.sorted { ($0.startTime ?? Date.distantPast) < ($1.startTime ?? Date.distantPast) }
        
        print("   Filtered count: \(filteredEvents.count)")
        return filteredEvents
    }
    
    // MARK: - Category Management
    func createCategory(name: String, icon: String, colorHex: String) -> Result<Category, Error> {
        let context = persistence.container.viewContext
        
        guard !name.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else {
            return .failure(ScheduleError.invalidCategoryName)
        }
        
        let category = Category(context: context)
        category.id = UUID()
        category.name = name.trimmingCharacters(in: .whitespacesAndNewlines)
        category.iconName = icon
        category.colorHex = colorHex
        category.isActive = true
        category.isDefault = false
        category.sortOrder = Int32(categories.count)
        category.createdAt = Date()
        // No updatedAt field in Core Data model
        
        do {
            try context.save()
            print("‚úÖ Category created: \(name)")
            return .success(category)
        } catch {
            lastError = "Failed to create category: \(error.localizedDescription)"
            print("‚ùå \(lastError ?? "")")
            return .failure(error)
        }
    }
}

// MARK: - NSFetchedResultsControllerDelegate
// NSFetchedResultsControllerDelegate conformance
extension ScheduleManager: NSFetchedResultsControllerDelegate {
    nonisolated func controllerDidChangeContent(_ controller: NSFetchedResultsController<NSFetchRequestResult>) {
        Task { @MainActor in
            if controller == fetchedResultsController {
                let oldCount = events.count
                events = fetchedResultsController?.fetchedObjects ?? []
                print("üîÑ NSFetchedResultsController: Events updated (\(oldCount) -> \(events.count))")
                
                // Debug: Show all events after update
                let formatter = DateFormatter()
                formatter.dateFormat = "yyyy-MM-dd HH:mm"
                for event in events {
                    print("   - \(event.title ?? "Untitled") at \(formatter.string(from: event.startTime ?? Date()))")
                }
            } else if controller == categoriesFetchedResultsController {
                categories = categoriesFetchedResultsController?.fetchedObjects ?? []
                print("üîÑ NSFetchedResultsController: Categories updated (\(categories.count))")
            }
        }
    }
}

// MARK: - Error Types
enum ScheduleError: LocalizedError {
    case invalidTitle
    case invalidTimeRange
    case invalidCategoryName
    case eventNotFound
    
    var errorDescription: String? {
        switch self {
        case .invalidTitle:
            return "Event title cannot be empty"
        case .invalidTimeRange:
            return "End time must be after start time"
        case .invalidCategoryName:
            return "Category name cannot be empty"
        case .eventNotFound:
            return "Event not found"
        }
    }
}